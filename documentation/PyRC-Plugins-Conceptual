Documentation - Plugin Theory: (Hey, this is the exact same set of rules PyRC's
				author uses, so of course they're practical. ^^)
Plugins under PyRC are intended to be written in Python. As such, they will be
able to take advantage of all facets exposed by the PyRC framework.

Plugins will be executed in the order that they are loaded, with their
respective authors being expected to handle logistics issues such as I/O 
blocking. Facilities will be provided to make this process easier, and templates
will be included with the standard distribution (in fact, a sample Google script
will be provided that demonstrates waiting for TCP/IP input, setting hooks and
executing a simple help response, and demonstrating context access).


Documentation - Plugin Implementation:
Communication standards:
 All inter-modular communications (within official code -- plugin authors are
 free to do whatever they want within their own domain) are to be handled by an
 implementation of Observer/Observable defined by PyRC's author, Neil Tallim
 (it'll be intuitive, and you'll never actually need to know how it works, I
 promise). So, basically, you can ignore all of that 'cause the messages will
 make it to your plugin properly.

 The IRC Abstraction Interface (PyRC.ircAbstract.ircInterface) will generate
 Python Dictionaries containing details related to incoming IRC events (and
 events generated by plugins, such as printing a status message to a channel
 List [that'll fire off a new channel message event, which will in turn cause
 the IRC Interface to generate another event]). These Dictionaries will be
 passed to each plugin (assuming the plugin has hooked the event -- more on
 hooking later) in sequence, and it's up to them to decide what to do with the 
 information.

 Example of an Event Dictionary:
  {
   'eventname': "Channel Message",
   'userdata': {#This is a reference to an existing user Dictionary
		 #(PyRC.ircAbstract.ircUser.returnData()).
		 'ident': "~rhx",
		 'hostmask': "cg.shawcable.net",
		 'country': "Network/Unknown",
		 'realname': "Neil Tallim",
		 'ircserver': "irc.zogm.hamsterx.net",
		 'lastevent': "16:24.12, September 20, 2004",
		 'username': "Red_HamsterX"
		}
   'irccontext': 0,
   'ircchannel': "#pyrc",
   'message': "This is a test."
  }
 Other events will have their own Dictionaries; their definitions will be
 provided later in this documentation.

Implementation standards:
 Plugins must exhibit a few specific behaviours (yeah, I'm forcing you to do
 things. I never said I wouldn't, but it's still mean t.t).
 These behaviours will be as follows, and implementation will be simple.
  
  On load, plugins will be expected to hook events they wish to receive.
  The syntax for this will be pretty straightforward. In fact, an example
  script is below.

   __module_name__="Test script"
   __moule_version__=1.0

   import sys
   #import statements can be used, and some cool tricks (how would you like to
   #have your own connection to an IRC server that the GUI doesn't touch?) will
   #be mentioned in the advanced portion of the plugin documentation.

   def hookEvent(dictIn, IAL):#Required if any non-Idle events have been hooked.
   	if dictIn['eventname']=="Channel Message":
		pass #This is just an example of structure.
	elif dictIn['eventname']=="Private Message":
		pass #This is still an example. In this case, we know of two
		#     events we want to deal with.

	return <List of RaisedEvent Dictionaries | [None]>

   def loadMe(IAL):#Required.
	#Put any setup code you need here -- create objects, set parameters,
        #whatever.
	
	return <HookMe List>

   def unloadMe():#Required.
	#Put any destruction code you need here -- deference objects the GC
	#won't otherwise hit, write to a logfile, broadcast sensitive data to
	#a remote ser... We'll forget that part. ^^;
	
   #Of course, you can put code here, too, but the loadMe(IAL) function would
   #probably be a better place for it. Your call, though.

  Now, readers who know Python will probably have an idea of what these things
  mean -- those of you coming from an mIRC background probably haven't seen
  'return' statements before, but don't worry, you'll catch on soon enough.
  However, for clarification, the code above will be explained.

   First, the '__module_name__' and '__module_version__' parameters:
    These are based on the X-Chat Python model, and are used purely to help
    keep track of running plugins. Running UIs (and even other, advanced
    plugins) can read the list of loaded plugins and provide you with this
    information. They're required parameters, but only for the sake of
    consistency. Note that __module_version__ is a floating point number, not a
    string. This has to be done to allow plugins to communicate directly.

   Next, the 'import sys' line:
    Python is a pretty extensible language (the fact that you can have plugins
    in the same language and project space the client itself is written in is
    proof of this), and it has a good deal of functionality included with its
    core packages. This "imports" the 'sys' module, and gives you access to its
    functions. We don't use 'sys' in this example, but it should be noted that
    writing a plugin does not restrict you to the code that you write by
    yourself.

   Next, the 'def hookEvent(dictIn, IAL):' line:
    Python, like any other language, has functions (also known as methods to
    you Java coders). This declares a function by the name of 'hookEvent' that
    accepts 'dictIn' (always a Python Dictionary due to the implementation of 
    PyRC -- typecheck if you must, but know it's just a waste of cycles) which 
    conforms to the PyRC Event Dictionary specs. Basically, this function gets
    an event from the IRC Abstraction Interface (PyRC.ircAbstract.ircInterface)
    which lets it know what happened, and allows the plugin to react
    accordingly.

    Only events which a plugin has registered for will be accepted, so if you
    know you need only one event, you can skip the if block and just act on the
    contents -- they will *always* conform to the specs.

    When the plugin has finished its evaluation/execution cycle, an (optional)
    return statement is used to communicate with other components of PyRC.
    This is a powerful feature. You can initate any number of events, even
    mirroring the behaviour of an IRC server, or cooler still, sending
    information to other plugins. (I don't get out much. You can tell, right?)

    The structure of a RaiseEvent Dictionary is as follows:
     {
      'behaviour': <"precedence"|"forward"|"skiprest"|"skipall">,
      		   #The distinction between these is important.
                   #"precedence": Overwrite the Event Dictionary passed down
                   #the plugin line with the one in this RaiseEvent Dictionary.
                   #"forward": Send the Event Dictionary (user-defined) in this
                   #RaiseEvent Dictionary to the named plugin's named function.
		   #"skiprest": Skip all remaining plugins in the line.
		   #"skipall": End processing here -- nothing else will get this
		   #Event Dictionary, not even the UI.
      'eventdictionary': <The Dictionary to send>, #Required.
      'targetplugin': <The __module_name__ parameter of a plugin. The first
                       match will be used. (Be careful!)>, #Only specified if
		       #'behaviour' is "forward".
      'targetfunction': <The literal name of a function in targetplugin.>,
                       #Only specified if 'behaviour' is "forward".
      'targetversion': <A version string> #An optional redundant check against
                                          #"targetplugin" -- RegExp patterns can
					  #be used if you need to ensure a
					  #specific version or version range.
					  #Note that if the version doesn't
					  #match, the message will not be sent.
     }
    
    The purpose of "forward" and "abstraction" is self-evident, but 
    "precedence" might not be so clear. It's used if, say, you wanted to filter
    a string another user said -- maybe you want to add colour to some words,
    or replace "spoon" with "spork". The UI plugins is always the last to
    receive any event, so filter away -- it'll always work. :)
    Note: You can have multiple RaiseEvent Dictionaries -- in fact, you should.
    Just wrap them in a Python List (you'll see what I mean when the Google
    plugin is presented).
    
    If the intent of your plugin is simply to log a channel (this will be
    provided as a default plugin, 'cause logging is good), then you may wish to
    `return None`, or simply omit the return statement.

   Next, the 'def idleCall(IAL):' line. # Removed. Just retain the reference to
   the IAL and pass dictionaries when done. Simple. :)
    This is a special function -- you'll probably never have to use this if you
    just want to say "Boo!" when a user enters a channel or whatever. If you
    want to do something more productive, though, this function is for you.
    
    This function is called for modules which have hooked "Idle Call" as an
    event. When that event is raised (PyRC will decide when based on internal
    algorithms; see source for details), this function will be invoked, and the
    code inside of it will run. Ideally, you'll want to do something like check
    the progress of a Thread here, or see if you've established a connection
    with a web server (we'll do both in the Google example <3). Since you don't
    want to make every other element in PyRC wait while a slow process
    executes, you should `return None` if your plugin isn't ready. If it is
    ready, the same RaiseEvent Dictionary implementation as outlined above can
    be used.

   Now, we'll look at 'def loadMe(IAL):'.
    This is a required function, and it *must* (if you want your plugin to do
    something more useful than idly occupy part of PyRC's memory) hook at least
    one event.

    Hooking events is easy. How easy? See below.
     return [
      "Channel Message",
      "Private Message"
     ]

    And it's done. This plugin will now receive both "Channel Message" and 
    "Private Message" events.

   Lastly, the 'def unloadMe():' line.
    Like loadMe(), this is a required function. If you're sure your module
    will be GCd cleanly, you can just run `pass` here. PyRC will dereference it
    and go about business as usual. If, however, you have an open connection to
    a database or something, you might want to consider closing that first;
    this is your chance to do so.

   Okay, okay... The IAL thing wasn't explained above. That's 'cause I just
   rewrote this code based on new research. Why's it there? That's a direct
   reference to the same interface PyRC is based on. Simply put, that's how you
   can access *literally* anything PyRC can do. It has one function of
   particular interest: passDict(<Dictionary>). This function takes a
   spec-compliant Event Dictionary and (based on the Dictionary's definition -- 
   check the Dictionary documentation) returns an Information Dictionary, or
   performs an action. So, uhh... it's powerful. Use it.
   
And, from a design standpoint, that's really all you should need to know to
plan plugin development. Wasn't that easy?

Below, you'll find detailed information on specs related to plugin development,
internal communication, a sample script which listens for "!google <term>" in a
channel and informs users of the first matching link, and some concepts and 
code snippits the author/programmer thinks are really frickin' cool.



The Plugin Manager module will write to crash.log whenever a module does
something that causes an exception to be raised. It will write the timestamp,
then the stack trace.

