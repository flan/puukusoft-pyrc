Clients able to act as HTTP gateways for other clients -- plugin module

DCC module -- handle DCC chat events and such 'cause they're effectively server independent.

SSL support?

ircStatus doesn't exist 'cause it's really, really close to ircServer.

The entire GUI/CLI will be just a plugin (PyRC.UIs.PyRCGUI;PyRC.UIs.PyRCCLI) that uses the unified
 interface abstraction layer -- other plugins can be added, too; they'll have
 special code in PyRC.py which sends events to them *last* -- after every other
 loaded plugin has run.
 Other plugins will have the ability to call each other by explicit calls:
 (passToPlugin(pluginName:String, pluginFunction:String, pluginArgs:Dictionary))
  getattr will be used to resolve this communication.
 The order in which calls will be passed is based on load order, and it is
 therefore possibe that, in a haphazard environment, a plugin that needs
 information from another plugin will run first -- this plugin should exhibit
 "pass" behaviour in its load (non-classed) code, and react only when key
 functions are called -- this will make the plugin structure much more flexible
 without having to worry about threadsynching.
 Plugins will also have access to a special call (passToGUI(stuffToPass:Dict))
 which will allow them to send specific data to GUI components (controlled, but
 flexible) while circumventing the IRC layer. This will probably never be used
 because it provides no persistence, but could be important in some cases.
 	The above explaination to be rewritten for clarity and included in
	release documentation.
 
Calculate timezone difference between you and whoever else.

Plugins revised:
 PyRC will dynamically load modules by path.
 When a module is loaded, it is executed (duh), and it must pass a list as
 an exception before its initialization has run through. This list must
 contain the following:
  String: "HookMe"
  String: "<named event>"
  ...
  String: "<named event>"
  
  where 'named event' is any event that the module wants to receive, and
  "HookMe" informs the plugin interface that these events are to be passed.
  
 When a plugin no longer needs to receive events (the unload event, maybe), it 
 can raise another list containing the following:
   String: "UnhookMe"
   String: "<named event>"
   ...
   String: "<named event>"
   
   where named event means the same thing as above.
   
  Hook/Unhook events can be raised at any time.
  
  Any hooked event is passed to "HookedEvents(eventData:Dictionary)" which must 
  be user-defined in the plugin module.
  "HookedEvents(eventData:Dictionry)" will also be defined in any UI plugin.
  *ALL* events will be passed to UI modules, without exception.
  
  Further, all plugins are to be handled by an interface-level threading
  mechanism. There will be no need for the individual plugins to worry about
  self-threading, 'cause that would just be counter-productive. (Implement
  threading.Thread in the class which contains a plugin; run "start()" right
  after loading its data.)

del <dictname>[<dictkey>] removes an element from a dictionary -- important.


NOTE:
 For the adventurous plugin author, it's entirely possible to import .py 
files in known namespace (env's current path). Thus, the entire IRC 
abstraction interface can be accessed if you wanted to, say, leave a listener 
in a channel to pick up lines said by a bot.




Documentation - Plugin Theory: (Hey, it's the exact same philosophy PyRC's author users, so of course it's practical. ^^)
Plugins under PyRC are intended to be written in Python. As such, they will be able to take advantage of all facets exposed by the PyRC framework.

Plugins will be executed in the order that they are loaded, with their respective authors being expected to handle logistics issues such as I/O blocking. Facilities will be provided to make this process easier, and templates will be included with the standard distribution (in fact, a sample Google script will be provided that demonstrates waiting for TCP/IP input, setting hooks and executing a simple help response, and demonstrating context access).


Documentation - Plugin Implementation:
Communication standards:
 All inter-modular communications (within official code -- plugin authors are
 free to do whatever they want within their own domain) are to be handled by an
 implementation of Observer/Observable, defined by PyRC's author, Neil Tallim
 (it'll be intuitive, and you'll never actually need to know how it works, I
 promise). So, basically, you can ignore all of that 'cause the messages will
 make it to your plugin properly.

 The IRC Abstraction Interface (PyRC.ircAbstract.ircInterface) will generate
 Python Dictionaries containing details related to incoming IRC events (and
 events generated by plugins, such as printing a status message to a channel
 List [that'll fire off a new channel message event, which will in turn cause
 the IRC Interface to generate another event]). These Dictionaries will be
 passed to each plugin (assuming the plugin has hooked the event -- more on
 hooking later) in sequence, and it's up to them to decide what to do with the 
 information.

 Example of an Event Dictionary:
  {
   'eventname': "Channel Message",
   'userdata': {#This is a reference to an existing user Dictionary
		 #(PyRC.ircAbstract.ircUser.returnData()).
		 'ident': "~rhx",
		 'hostmask': "cg.shawcable.net",
		 'country': "Network/Unknown",
		 'realname': "Neil Tallim",
		 'ircserver': "irc.zogm.hamsterx.net",
		 'lastevent': "16:24.12, September 20, 2004",
		 'username': "Red_HamsterX"
		}
   'ircnetwork': "hamsterx.net",
   'ircchannel': "#pyrc",
   'action': False,
   'message': "This is a test."
  }
 Other events will have their own Dictionaries; their definitions will be
 provided later in this documentation.

Implementation standards:
 Plugins must exhibit a few specific behaviours (yeah, I'm forcing you to do
 things. I never said I wouldn't, but it's still mean t.t).
 These behaviours will be as follows, and implementation will be simple.
  
  On load, plugins will be expected to hook events they wish to receive.
  The syntax for this will be pretty straightforward. In fact, an example
  script is below.

   __module_name__="Test script"
   __moule_version="1.0"

   import sys
   #import statements can be used, and some cool tricks (how would you like to
   #have your own connection to an IRC server that the GUI doesn't touch?) will
   #be mentioned in the advanced portion of the plugin documentation.

   def hookEvent(dictIn):#Required if any non-Idle events have been hooked.
   	if dictIn['eventname']=="Channel Message":
		pass #This is just an example of structure.
	elif dictIn['eventname']=="Private Message":
		pass #This is still an example. In this case, we know of two
		#     events we want to deal with.

	return <List of RaisedEvent Dictionaries | [None]>

   def idleCall():#Required if the Idle event has been hooked.
	pass #This is a very important method for I/O-bound plugins. You'll
	#     probably never need to write this function for a normal plugin,
	#     but it's important to know that it exists.

	return <List of RaisedEvent Dictionaries | [None]>

   def loadMe():#Required.
	#Put any setup code you need here -- create objects, set parameters,
        #whatever.
	
	return <HookMe List>

   def unloadMe():#Required.
	#Put any destruction code you need here -- deference objects the GC
	#won't otherwise hit, write to a logfile, broadcast sensitive data to
	#a remote ser... We'll forget that part. ^^;
	
   #Of course, you can put code here, too, but the loadMe() function would
   #probably be a better place for it. Your call, though.

  Now, readers who know Python will probably have an idea of what these things
  mean -- those of you coming from an mIRC background probably haven't seen
  'return' statements before, but don't worry, you'll catch on soon enough.
  However, for clarification, the code above will be explained.

   First, the '__module_name__' and '__module_version__' parameters:
    These are based on the X-Chat Python model, and are used purely to help you
    keep track of running plugins. Running UIs (and even other, advanced
    plugins) can read the list of loaded plugins and provide you with this
    information. They're required parameters, but only for the sake of
    consistency -- you could put "Foam cheese" into both of them, and the
    plugin would work fine.

   Next, the 'import sys' line:
    Python is a pretty extensible language (the fact that you can have plugins
    in the same language and project space the client itself is written in is
    proof of this), and it has a good deal of functionality included with its
    core packages. This "imports" the 'sys' module, and gives you access to its
    functions. We don't use 'sys' in this example, but it should be noted that
    writing a plugin does not restrict you to the code that you write by
    yourself.

   Next, the 'def hookEvent(dictIn):' line:
    Python, like any other language, has functions (also known as methods to
    you Java coders). This declares a function by the name of 'hookEvent' that
    accepts 'dictIn' (always a Python Dictionary due to the implementation of 
    PyRC -- typecheck if you must, but know it's just a waste of cycles) which 
    conforms to the PyRC Event Dictionary specs. Basically, this function gets
    an event from the IRC Abstraction Interface (PyRC.ircAbstract.ircInterface)
    which lets it know what happened, and allows the plugin to react
    accordingly.

    Only events which a plugin has registered for will be accepted, so if you
    know you need only one event, you can skip the if block and just act on the
    contents -- they will *always* conform to the specs.

    When the plugin has finished its evaluation/execution cycle, an (optional)
    return statement is used to communicate with other components of PyRC.
    This is a powerful feature. You can initate any number of events, even
    mirroring the behaviour of an IRC server, or cooler still, sending
    information to other plugins. (I don't get out much. You can tell, right?)

    The structure of a RaiseEvent Dictionary is as follows:
     {
      'behaviour': <"precedence"|"forward"|"abstraction">,#The distinction
                   #between these is important.
                   #"precedence": Overwrite the Event Dictionary passed down
                   #the plugin line with the one in this RaiseEvent Dictionary.
                   #"forward": Send the Event Dictionary (non-spec compliant)
                   #in this RaiseEvent Dictionary to the named plugin's named
                   #function.
                   #"abstraction": Pass this RaiseEvent Dictionary's Event
                   #Dictionary to the IRC Abstraction Interface
                   #(PyRC.ircAbstract.ircInterface)'s getEvent(dictIn) method.
                   #This Event Dictionary *must* be spec-compliant.
      'eventdictionary': <The Dictionary to send>, #Required.
      'targetplugin': <The __module_name__ parameter of a plugin. The first
                       match will be used.>, #Only specified if 'behaviour' is
                       #"forward".
      'targetfunction': <The literal name of a function in targetplugin.>
                       #Only specified if 'behaviour' is "forward".
     }
    
    The purpose of "forward" and "abstraction" is self-evident, but 
    "precedence" might not be so clear. It's used if, say, you wanted to filter
    a string another user said -- maybe you want to add colour to some words,
    or replace "spoon" with "spork". The UI plugins is always the last to
    receive any event, so filter away -- it'll always work. :)
    Note: You can have multiple RaiseEvent Dictionaries -- in fact, you should.
    Just wrap them in a Python List (you'll see what I mean when the Google
    plugin is presented).
    
    If the intent of your plugin is simply to log a channel (this will be
    provided as a default plugin, 'cause logging is good), then you may wish to
    `return None`, or simply omit the return statement.

   Next, the 'def idleCall():' line.
    This is a special function -- you'll probably never have to use this if you
    just want to say "Boo!" when a user enters a channel or whatever. If you
    want to do something more productive, though, this function is for you.
    
    This function is called for modules which have hooked "Idle Call" as an
    event. When that event is raised (PyRC will decide when based on internal
    algorithms; see source for details), this function will be invoked, and the
    code inside of it will run. Ideally, you'll want to do something like check
    the progress of a Thread here, or see if you've established a connection
    with a web server (we'll do both in the Google example <3). Since you don't
    want to make every other element in PyRC wait while a slow process
    executes, you should `return None` if your plugin isn't ready. If it is
    ready, the same RaiseEvent Dictionary implementation as outlined above can
    be used.

   Now, we'll look at 'def loadMe():'.
    This is a required function, and it *must* (if you want your plugin to do
    something more useful than idly occupy part of PyRC's memory) hook at least
    one event.

    Hooking events is easy. How easy? See below.
     return [
      "Channel Message",
      "Private Message"
     ]

    And it's done. This plugin will now receive both "Channel Message" and 
    "Private Message" events.

   Lastly, the 'def unloadMe():' line.
    Like loadMe(), this is a required function. If you're sure your module
    will be GCd cleanly, you can just run `pass` here. PyRC will dereference it
    and go about business as usual. If, however, you have an open connection to
    a database or something, you might want to consider closing that first;
    this is your chance to do so.

And from a design standpoint, that's really all you should need to know to
plan plugin development. Wasn't that easy?

Below, you'll find detailed information on specs related to plugin development,
internal communication, a sample script which listens for "!google <term>" in a
channel and informs users of the first matching link, and some concepts and 
code snippits the author/programmer thinks are really frickin' cool.
